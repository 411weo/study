# C++
## 大端小端
- 现在计算机都是按字寻址，可能一个地址存放的内容大于一个字节，此时需要考虑数据在内存中存放的顺序问题，大端就是数据高位在低地址处，数据低位在高地址处。小端则相反。
## 孤儿进程 僵尸进程
- 孤儿进程就是父进程已经退出，而子进程依然还在运行。
- 僵尸进程就是父进程用fork创建子进程，子进程退出而父进程没有调用wt()或者wtpid()系统调用获取子进程的终止状态，那么子进程的进程描述符依然保留在系统中，占用资源。
## 进程通信
- 进程中通信的方式有管道通信，套接字通信，共享内存，信号量，信号，消息队列等。
## 线程通信
- 线程通信的方式有线程同步、锁、条件变量、信号量等。
## 进程与线程的区别
- 进程是OS调度的基本单位，有独立的地址空间。
- 线程与其他线程共享一个进程的资源。
- 进程切换开销大、进程并发低、线程挂了其他线程也会挂、进程挂了一般不会影响其他进程。
## 线程与协程
- 协程是一个由用户管理，所以又称为用户态线程。线程是并行的，而协程是并发的。
## 死锁
- 死锁是多个程序相互占有其他程序需要的资源，并且不释放，导致这几个程序无法继续运行。
- 产生死锁的必要条件有1、某个资源在运行时只能由一个程序使用2、程序已经占有了某个被共享的资源3、程序占有的资源不能被剥夺4、多个程序之间存在资源的环路等待。
## 函数指针
- 定义一个指向函数的指针，可以让函数作为参数传递、用于实现回调。
- return_type (*function_ptr)(parameter_types);
- int (*add_ptr)(int, int);
## 写时拷贝
- 写时拷贝是指写的时候才分配内存空间，当某个进程用fork创建子进程时，子进程暂时与父进程暂时共享内存空间。当某个进程需要写入时，才会复制一份，供另外一个进程使用。
## 为什么要创建子进程
- 提高程序的执行效率，子进程可以并行执行。
- 模块化设计，将不同的功能模块化，结构清晰。
- 错误隔离，子进程通常不会影响父进程和其他子进程，提高稳定性。
- 资源隔离，子进程拥有独立的地址空间。
## 分段和分页
- 分段和分页是是常用得内存管理技术。
- 分段是根据程序的逻辑结构将内存空间划分为几个段、例如代码段、数据段、堆段等。
- 分页是将程序的地址空间分为若干大小相等的页，与内存中的地址块相对应。页与块的大小一样。
## 互斥锁与自旋锁
- 互斥锁：共享资源只运行一个进程进行访问。当加锁失败时，进程被挂起。
- 自旋锁：进行没有请求到锁后会原地等待，直到锁被释放。
## 共享内存
- 进程间通信的一种方式，多个进程可以对同一块物理地址进行访问，缺点是缺少同步机制。
## 条件变量
- 线程间通信的方式，一个线程使线程满足，一个线程在等待条件不足时挂起。条件变量会被多线程读写，需要加互斥锁。
## TCP是如何保证可靠传输的
- 序列号确认、超时重传、检验和
## HTTP与HTTPS的区别
- http是明文传输，安全性差，一次TCP连接，传播耗时一个RTT
- https是http+ssl/tls 加密传输，包含两次tcp连接，耗时3个rtt
## http常见状态码
- 1xx 服务器接受了请求
- 2xx 代表服务器已成功接受了请求
- 3xx 请求被重定向到一个新地址
- 4xx 发生了错误
- 5xx 服务器响应发生了错误
## get与post的区别
  - get与post 都是对发送服务端请求，但get发送的请求有长度限制，请求可附在url中通过？与&连接，post请求会放在请求体中，并可发送表单请求。
## 拥塞控制机制
  - 慢开始、拥塞避免，快重传、快恢复。
## 静态库与动态库
  - 静态库与动态库库的区别在于程序依赖于别的库时，静态库会和源程序打包成一个exe文件，这个exe文件可独立执行，依赖动态库的程序编译成exe文件后，该exe执行时还需依赖动态库文件。所以静态库在编译的时候已经链接好，而动态库会在程序启动时动态链接。动态库更新时方便，只需更新动态库文件即可，而静态库更新时，整个程序需要重新编译。动态库在linux与win下面是.so文件和.ddl文件，静态库是.a和.lib文件。
 ## 结构体与类
 - 结构体一般表示一堆数据的集合，而类用于封装某个对象的属性和行为。
 - c++中class的默认访问权限是private，struct的默认访问权限是public；
 - c中结构体不允许继承，不允许有函数，不支持默认初始化。
## static 关键字的作用
- static关键字修饰的遍历只能在当前源文件中访问。
- static在类中修饰的变量被类的所有对象共享，static修饰的成员函数只能访问static修饰的变量。
- static可以延长数据的生命周期，因为static修饰的变量为放在静态区，程序结束后才会释放。
## 什么是野指针
- 野指针就是指向了未知地址的指针，例如没有初始化或者随机初始化，释放后没有赋值为nullptr，或者超出了函数的作用范围(指向了函数返回了局部变量的地址）。
## const与define的区别
- const用来定义常量，避免被修改，define用来进行宏定义，在编译时进行替换，避免没有意义的字符和字符串，便于程序的阅读。
## extern 的作用
- 由于c与c++的区别，当c与c++相互调用时，可能会出现链接错误（c++中有函数重载的概念，对同名的函数有复杂的修饰规则，c语言没有)。使用 extern "C" 可以确保链接时使用的是C语言的名称修饰规则，从而避免名称冲突。
- extern 修饰函数或变量表示该函数或变量定义在别的文件。
- extern变量表示声明一个变量，表示该变量是全局变量，extern 修饰的变量保存在静态存储区，初始化为0保存在BSS段，不初始化为0保存在DATA段。
## const的用法
- const可以用于定义常量，初始化后就不能被修改。
- const可以用于修饰成员函数参数，函数内不能修改参数的值。
- 在类中修饰成员方法，防止在方法中修改非 static 成员，const 修饰的成员方法中不能修改非静态成员变量。
- const 修饰类的成员变量，如果 const 修饰的是非静态的成员变量，可以在构造函数中对该变量进行初始化；如果 const 修饰的是静态的成员变量，则需要在类外对该变量进行初始化。
## sizeof
- sizeof 的原理：sizeof 是在编译的时候，查找符号表，判断类型，然后根据基础类型来取值。如果 sizeof 运算符的参数是一个不定长数组，则该需要在运行时计算数组长度。注意是编译时不是运行时。所以sizeof(a++)，不会导致a的值改变。
- sizeof 表示该数据占用的字节数。
## volatile关键字
- volatile 关键字的作用主要是告诉编译器该变量可能会在程序的控制之外改变，告诉编译器不要优化。
- 可以与const一起使用，const只是表明在代码中不能修改值。
## 引用
- 引用就是对已存在的一个变量取别名，所以引用在声明时就必须初始化，初始化后就不能指向其他对象。
- 可以使用const关键字声明一个常量引用，这意味着不能通过这个引用来修改它所绑定的对象。
- 本质是指针常量。
## 指针与引用的区别
- 指针是一个数据类型，用于保存数据的存放地址。
- 指针可以是空值，引用必须指向已存在的对象。
- 可以多级指针，但不能多级引用。
## 内联函数 inline
- inline用于修饰一些简单的函数，建议编译器在遇到时直接进行代码替换，避免调用函数的开销。
## c++的内存管理
- 运行时的内存布局通常被分为几个主要区域。
- 栈（Stack）：用于存储局部变量和函数调用时的上下文信息。通常在函数调用时自动分配和释放内存。
- 堆（Heap）：动态内存分配区域，用于存储程序运行时动态创建的对象。由程序员手动管理内存的分配和释放。
- 代码区（Code Area 或 Text Segment）：存储程序的可执行代码和一些只读数据。这部分内存通常是只读的，以防止程序代码被意外修改。
- 数据段（Data Segment）：存储程序中已初始化的全局变量和静态变量。
- BSS段（BSS Segment）：存储程序中未初始化的全局变量和静态变量。BSS是“Block Started by Symbol”的缩写。
- 全局/静态区（Global/Static Area）：存储全局变量和静态变量。这些变量的生命周期贯穿整个程序的运行过程。
- 常量区（Constant Area）：存储程序中的常量数据。
## 堆区和栈区的区别
- 栈区由编译器管理，堆区由程序员管理。
- 栈有空间限制，堆一般来说没有。
- 堆由于是程序员自己控制，会产生大量的内存碎片，栈没有内存碎片的问题。
- 堆的生长方向是向内存地址增加的方向，栈则相反。
## 内存泄漏
    
