# C++
## 大端小端
- 现在计算机都是按字寻址，可能一个地址存放的内容大于一个字节，此时需要考虑数据在内存中存放的顺序问题，大端就是数据高位在低地址处，数据低位在高地址处。小端则相反。
## 孤儿进程 僵尸进程
- 孤儿进程就是父进程已经退出，而子进程依然还在运行。
- 僵尸进程就是父进程用fork创建子进程，子进程退出而父进程没有调用wt()或者wtpid()系统调用获取子进程的终止状态，那么子进程的进程描述符依然保留在系统中，占用资源。
## 进程通信
- 进程中通信的方式有管道通信，套接字通信，共享内存，信号量，信号，消息队列等。
## 线程通信
- 线程通信的方式有线程同步、锁、条件变量、信号量等。
## 进程与线程的区别
- 进程是OS调度的基本单位，有独立的地址空间。
- 线程与其他线程共享一个进程的资源。
- 进程切换开销大、进程并发低、线程挂了其他线程也会挂、进程挂了一般不会影响其他进程。
## 线程与协程
- 协程是一个由用户管理，所以又称为用户态线程。线程是并行的，而协程是并发的。协程的创建开销小，不需要经过内核。
## 死锁
- 死锁是多个程序相互占有其他程序需要的资源，并且不释放，导致这几个程序无法继续运行。
- 产生死锁的必要条件有1、某个资源在运行时只能由一个程序使用2、程序已经占有了某个被共享的资源3、程序占有的资源不能被剥夺4、多个程序之间存在资源的环路等待。
## 函数指针
- 定义一个指向函数的指针，可以让函数作为参数传递、用于实现回调。
- return_type (*function_ptr)(parameter_types);
- int (*add_ptr)(int, int);
## 写时拷贝
- 写时拷贝是指写的时候才分配内存空间，当某个进程用fork创建子进程时，子进程暂时与父进程暂时共享内存空间。当某个进程需要写入时，才会复制一份，供另外一个进程使用。
## 为什么要创建子进程
- 提高程序的执行效率，子进程可以并行执行。
- 模块化设计，将不同的功能模块化，结构清晰。
- 错误隔离，子进程通常不会影响父进程和其他子进程，提高稳定性。
- 资源隔离，子进程拥有独立的地址空间。
## 分段和分页
- 分段和分页是是常用得内存管理技术。
- 分段是根据程序的逻辑结构将内存空间划分为几个段、例如代码段、数据段、堆段等。
- 分页是将程序的地址空间分为若干大小相等的页，与内存中的地址块相对应。页与块的大小一样。
## 互斥锁与自旋锁
- 互斥锁：共享资源只运行一个进程进行访问。当加锁失败时，进程被挂起。
- 自旋锁：进行没有请求到锁后会原地等待，直到锁被释放。
## 共享内存
- 进程间通信的一种方式，多个进程可以对同一块物理地址进行访问，缺点是缺少同步机制。
## 条件变量
- 线程间通信的方式，一个线程使线程满足，一个线程在等待条件不足时挂起。条件变量会被多线程读写，需要加互斥锁。
## 静态库与动态库
  - 静态库与动态库库的区别在于程序依赖于别的库时，静态库会和源程序打包成一个exe文件，这个exe文件可独立执行，依赖动态库的程序编译成exe文件后，该exe执行时还需依赖动态库文件。所以静态库在编译的时候已经链接好，而动态库会在程序启动时动态链接。动态库更新时方便，只需更新动态库文件即可，而静态库更新时，整个程序需要重新编译。动态库在linux与win下面是.so文件和.ddl文件，静态库是.a和.lib文件。
 ## 结构体与类
 - 结构体一般表示一堆数据的集合，而类用于封装某个对象的属性和行为。
 - c++中class的默认访问权限是private，struct的默认访问权限是public；
 - c中结构体不允许继承，不允许有函数，不支持默认初始化。
## static 关键字的作用
- static关键字修饰的遍历只能在当前源文件中访问。
- static在类中修饰的变量被类的所有对象共享，static修饰的成员函数只能访问static修饰的变量。
- static可以延长数据的生命周期，因为static修饰的变量为放在静态区，程序结束后才会释放。
## 什么是野指针
- 野指针就是指向了未知地址的指针，例如没有初始化或者随机初始化，释放后没有赋值为nullptr，或者超出了函数的作用范围(指向了函数返回了局部变量的地址）。
## const与define的区别
- const用来定义常量，避免被修改，define用来进行宏定义，在编译时进行替换，避免没有意义的字符和字符串，便于程序的阅读。
## define与template的区别
- 宏使用define定义，目的是为了方便程序的阅读，在编译之前就将宏名替换成宏定义的内容。
- 模板是在编译时根据实际内容替换。
## 宏函数
- 使用define定义，可以接受参数，就像一个真正的函数一样，与函数不同的是，宏函数在预处理时就展开，而不是运行时调用。
- 改写成模板函数，使用template关键字定义一个新的模板函数，其参数类型使用模板参数表示。将宏函数中的逻辑转换为模板函数中的逻辑。确保模板函数中的操作与宏函数中的操作相同。
## extern 的作用
- 由于c与c++的区别，当c与c++相互调用时，可能会出现链接错误（c++中有函数重载的概念，对同名的函数有复杂的修饰规则，c语言没有)。使用 extern "C" 可以确保链接时使用的是C语言的名称修饰规则，从而避免名称冲突。
- extern 修饰函数或变量表示该函数或变量定义在别的文件。
- extern变量表示声明一个变量，表示该变量是全局变量，extern 修饰的变量保存在静态存储区，初始化为0保存在BSS段，不初始化为0保存在DATA段。
## const的用法
- const可以用于定义常量，初始化后就不能被修改。
- const可以用于修饰成员函数参数，函数内不能修改参数的值。
- 在类中修饰成员方法，防止在方法中修改非 static 成员，const 修饰的成员方法中不能修改非静态成员变量。
- const 修饰类的成员变量，如果 const 修饰的是非静态的成员变量，可以在构造函数中对该变量进行初始化；如果 const 修饰的是静态的成员变量，则需要在类外对该变量进行初始化。
## sizeof
- sizeof 的原理：sizeof 是在编译的时候，查找符号表，判断类型，然后根据基础类型来取值。如果 sizeof 运算符的参数是一个不定长数组，则该需要在运行时计算数组长度。注意是编译时不是运行时。所以sizeof(a++)，不会导致a的值改变。
- sizeof 表示该数据占用的字节数。
## volatile关键字
- volatile 关键字的作用主要是告诉编译器该变量可能会在程序的控制之外改变，告诉编译器不要优化。
- 可以与const一起使用，const只是表明在代码中不能修改值。
## 引用
- 引用就是对已存在的一个变量取别名，所以引用在声明时就必须初始化，初始化后就不能指向其他对象。
- 可以使用const关键字声明一个常量引用，这意味着不能通过这个引用来修改它所绑定的对象。
- 本质是指针常量。
## 指针与引用的区别
- 指针是一个数据类型，用于保存数据的存放地址。
- 指针可以是空值，引用必须指向已存在的对象。
- 可以多级指针，但不能多级引用。
## 内联函数 inline
- inline用于修饰一些简单的函数，建议编译器在遇到时直接进行代码替换，避免调用函数的开销。
## c++的内存管理
- 运行时的内存布局通常被分为几个主要区域。
- 栈（Stack）：用于存储局部变量和函数调用时的上下文信息。通常在函数调用时自动分配和释放内存。
- 堆（Heap）：动态内存分配区域，用于存储程序运行时动态创建的对象。由程序员手动管理内存的分配和释放。
- 代码区（Code Area 或 Text Segment）：存储程序的可执行代码和一些只读数据。这部分内存通常是只读的，以防止程序代码被意外修改。
- 数据段（Data Segment）：存储程序中已初始化的全局变量和静态变量。
- BSS段（BSS Segment）：存储程序中未初始化的全局变量和静态变量。BSS是“Block Started by Symbol”的缩写。
- 全局/静态区（Global/Static Area）：存储全局变量和静态变量。这些变量的生命周期贯穿整个程序的运行过程。
- 常量区（Constant Area）：存储程序中的常量数据。
## 堆区和栈区的区别
- 栈区由编译器管理，堆区由程序员管理。
- 栈有空间限制，堆一般来说没有。
- 堆由于是程序员自己控制，会产生大量的内存碎片，栈没有内存碎片的问题。
- 堆的生长方向是向内存地址增加的方向，栈则相反。
## 内存泄漏
- 内存泄漏是指程序动态申请的堆内存再使用完成后为对其释放造成的系统空间的浪费。
## 内存对齐
- cpu并不是一次性只能读取一个字节，为了减少cpu访问的时间，所以把数据的首地址放在k的整数倍(4或8）
- 硬件原因，某些硬件只能访问特殊地址。
## malloc函数原理
- malloc是程序员使用，故在堆区申请内存。linux维护了一个指针break，从堆起始指针到break之间的空间都是可以访问的。想增加实际使用的堆空间的大小，就需要移动break指针。linux系统提供brk和sbrk移动break指针。系统malloc函数实际上时维护了一个空闲内存链表，调用时会沿着链表搜索大于申请空间的内存。将其一分为二，与申请空间大小相同的给用户，剩下的放到链表中。如果没有搜索到，那么就会改变break指针来申请内存空间。free则将释放分内存空间返回给链表。
## new的实现原理
- new简单类型就是调用malloc函数，new 复杂对象 会调用operator new函数申请内存，然后再该内存是调用构造函数。
- new与molloc的区别 new是操作符 malloc是函数 new可以重载 malloc不能被重载。
## free与delete
- free 释放malloc申请的内存，delete释放new对象占有的内存。

## 面向过程与面向对象

## 重写与重载
- 重写是子类可以重新构建一个与父类相同名字，相同参数的函数。
- 重载是函数名可以相同，但函数的参数列表不同。
- 重写用于实现动态多态。
## 面向对象的三大特征
- 封装，将数据与对数据的行为封装起来，只对外暴露接口，隐藏其实现细节。通过private，public，protected关键字赋予不同的访问权限。提高了代码的复用性和安全性。
- 继承，子类继承父类，子类可以拥有父类的相同的数据与行为，同时子类也可以自己构建属于自己的数据与行为。提高了代码的复用性。
- 多态，多态是指基类的指针或引用，在运行时动态的调用实际绑定对象函数的行为。基类指针绑定基类对象就调用基类方法，基类指针绑定派生类对象就调用派生类方法，多态提高了代码的可读性和组织性。
## 虚函数
- 在成员函数前面添加virtual关键字。
- 成员函数分为非虚函数，虚函数，纯虚函数。其中虚函数希望子类重写，纯虚函数子类一定要重写。
- 虚函数主要体现了动多态，动多态简单说就是父类指针指向子类的示例，通过父类指针调用实际子类的成员函数。编译器处理虚函数时，会给对象添加一个虚函数指针，虚函数指针指向虚函数表，虚函数表中存储的是类中的虚函数地址，如果派生类中修改了基类的虚函数，则虚函数表中保存的是派生类的虚函数地址，如果没有重写则虚函数表中存储的是基类的虚函数地址，使用虚函数会增加一部跟开销，主要是加大对象所占的内存，因为对了一个虚函数指针，同时在调用过程中，需要有查表得操作，增加了时间上得开销。
- 纯虚函数父类中只提供了定义，实现去留给派生类。
- 虚析构函数的作用是为了防止内存泄漏。当一个类有虚函数时，通常也会有一个虚析构函数。当通过父类的指针指向子类对象时，如果调用了析构函数，可能子类并没有正确的被释放掉，导致内存泄漏。
## c++中的多态
- 静态多态：静态多态是在编译时执行的，例如函数重载，泛型编程，重载操作符等。编译器根据实际的类型来填充。
- 动态多态：动态多态则是通过虚函数实现，运行时通过调用对象的实际类型选择对应的虚函数。
## 深拷贝与浅拷贝
- 浅拷贝是在复制对象时只复制了对象的值，对于一些指向堆区的数据时，只是复制了其指针或引用，导致副本用的还是原对象的数据。调用析构函数还会导致
- 深拷贝首先申请一块和原对象一样大小的内存空间在进行复制操作。
- 默认拷贝构造函数和操作符重载函数都是浅拷贝。
## 重载 重写 隐藏
- 重载：函数之间或一个类中的函数，函数名相同，参数列表不同，称为函数重载。
- 重写：子类重写父类的虚函数，函数名与参数列表都相同，函数体不同
- 隐藏：子类重新实现父类中的函数，调用时调用子类中的函数，函数名相同，参数列表也相同，函数体不同。
## 拷贝与赋值
- 用一个对象去初始化另外一个对象时就是拷贝，赋值是将一个初始化的对象赋值给另一个已经初始化过的对象。
## 容器
#### 顺序容器
- vector 动态数组 底层是动态数组  首先申请capacity的空间 每次扩容是实际分配的空间都会比申请的空间大
- deque 双向队列
- list 双向链表
#### 关联式容器，以平衡二叉树实现
- set 不允许有相同元素 multiset 允许有相同元素
- map/multimap：是否运行有相同key值
#### 容器适配器
- queue stack priority_queue;
## map 与 unodored_map 
- map 是排序的  由 红黑树实现，unordered_map是由哈希表实现，出现哈希冲突时使用开链法。
## 智能指针
- 智能指针可以自动的调用析构函数，释放内存。指针是数据类型，智能指针是类模板。
- unique_ptr 确保只有一个unique_ptr 指向该对象
- shared_ptr 可以有多个 shared_ptr 指向该对象 ，维护一个计数器  当计数器为0的时候销毁该对象。
- weak_ptr 为了解决循环引用而引出，
## 可变参数模板类
-在 C++11 之前，类模板和函数模板只能含有固定数量的模板参数。C++11 增强了模板功能，它对参数进行了高度泛化，允许模板定义中包含 0 到任意个、任意类型的模板参数。
## 左值、右值、左值引用、右值引用
- 左值代表在内存中有具体的表达式，可以取地址，右值没有，用完就消失 int a = a+b; a是左值 a+b是右值
- 左值引用是指int &a = b; 引用出现在赋值表达式的左边
- 右值引用指向右值 int &&a = 5;
- 右值引用可以通过move函数引用左值，
## 设计模式
#### 单例模式
- 一个类只会有一个实例化对象
- 把类的构造和拷贝构造，赋值构造都设置为私有，避免其他方式构造对象，在类中私有化一个该类的静态指针，对静态成员类内声明类外初始化，初始化的时候直接构造对象是饿汉模式（线程安全），使用的时候才构造对象是懒汉模式。
- 饿汉模式：线程安全，因为对类中已经创建了一个该类的对象作为成员变量。
- 饱汉模式：使用的时候才开始实例化对象，所以线程不安全。
#### 工厂模式
- 定义创建对象的接口，让子类决定去实例化哪个对象
#### 观察者模式
- 对象中存在一对多的模式，当一个对象被改变。
# java
## java的优点
- 纯面向对象的编程语言，没有c++中复杂的指针，多继承概念。
- 一次编译，多次运行，依赖于JVM，java可以实现跨平台运行。
- 内置很多优秀的库。
## java的数据类型
- 基本数据类型：整型(int\short\long),浮点型，布尔型，字符型
- 引用类型：类、接口、数组
## 自动拆箱与自动装箱
- java每个基本数据类型都会有一个对应的类
- 自动装箱就是把基本数据类型转换成对应的类型。
- 自动拆箱就是把类转换成基本数据类型。
## 抽象类与接口
- 抽象类可以有普通方法，接口在1.8之前只能有抽象方法。
- 抽象类可以有常量，静态变量，成员变量，接口只能有常量。
- 抽象类可以有构造方法，接口不可以有构造方法。
- 类只能单一继承，接口可以重复继承。
## final关键字
- 修饰类类不能被继承
- 修饰方法方法不能被重写
- 修饰变量变量不能被修改
- 修饰引用，引用的地址不能改变。
## static 修饰符
- 在类中修饰方法，表示该方法属于整个类，不需要实例化对象就可以调用。
- 在类中修饰变量表示该变量属于整个类，可以被通过类名访问。
- 静态方法不能访问实例化变量。
## String类
- String 类被final修饰 不能继承，创建的对象也不能更改。
- 使用new创建String 对象 与直接使用常量字符串的区别在于直接使用常量字符串是由常量池管理，使用new时会先使用常量池创建常量，然后在堆中构造一个String对象。
## String StringBuffer StringBuilder
- String 类一旦被创建就不能修改，StringBuffer和StringBuilder为了解决这个问题StringBuffer是线程安全的类。
## == 和 equals 的区别
- 基本数据类型都是比较值是否相等
- 比较引用类型时==是比较地址是否相同，equals没有重写之前，也是比较地址，所以一般需要根据业务需求重写equals。
## hashcode与equals
- 用于计算哈希码，但重写了equals后，两引用类型是否相等的定于已经改变，此时为了确保equals为true的两个对象有同一个哈希码，也需要重写hashcode
## java异常处理机制
- 尝试执行可能出现错误的代码，当出现错误时抛出异常，异常可以根据错误类型判断。给予程序健壮性、可读性。
## 访问修饰符
- private 只能在该类中使用
- defaul 当前类或同属于一个包的其他类
- protected 当前类或同属于一个包的其他类及其子类
- public 所有类
## 泛型与泛型擦除
- 泛型是指我们可以用一个符号指代某种数据类型的数据，类和函数使用该符号，而不需要为每种数据类型都编写单独的代码。
- 泛型擦除是指在编译时进行泛型检查，运行时泛型擦除，即jvm不知道数据的类型是什么。与c++模板函数不一样，c++模板函数编译时就替换了。
## 反射
- 反射的使用是基于class对象来处理的。在java中每一个类都存在着它的class对象，通过编译后，每一个类都会生成与之相关.class文件用来存储这些类信息。反射就是通过获取这些类信息例如获取该类对象存在那些变量及其类型，存在那些方法和构造函数细节。获取到这些信息后就可以以反射的方式创建一个该对象并对其进行相关操作。反射的使用大大的提高了代码的可扩展性，实现了一些本不能实现的功能，例如动态代理中就常常用到了反射。但是它破环了java中内部细节不对外部公开的封装特性，所以滥用可能会导致一系列安全问题。同时使用反射会降低性能，因为java不会对反射代码进行优化。
## 多线程
- 线程是CPU调度的最小单元，一个进程可以存在多个线程，多个线程可以并发或者并行。每个线程有独立的运行栈和程序计数器，实现多线程有三种方式：继承Tread类，实现Runable接口；实现Callable接口。
## 线程的状态
- os层面创建，阻塞，就绪，运行，终止。
## wait与sleep的区别
- 一个是object类的实例方法，一个是thread的静态方法。
- wait依赖synchornozied锁，必须由其他线程调用notify才能唤醒。
## 如何保证线程安全
- 加锁，保证同一临界区内的变量同时只能由一个线程访问。
- 原子类，遵循CAS原则，比较是否等于期望值，不等于则替换。一个变量
- volatile关键字。一个变量加锁，轻量级synchoronized。保证线程读取该变量时总能看到该变量的最后一次写入。
## java线程同步
- java通过synchoronized和lock实现线程同步
## java 线程通信
-java使用monitor和condition实现线程通信
## 线程池的原理
- 接受到一个任务时判断线程数量是否达到了最大核心线程数量，没有则创建一个线程执行该任务
- 判断等待队列是否满了，未满则加入等待队列
- 判断线程数是否达到最大线程数量，没有则创建一个新线程执行任务。
- 拒绝执行任务
- 线程空闲时间超过一定值后则会销毁部分线程。
## ThreaLocal
- 将并发访问的资源复制多份，每个线程独享一份。底层靠map实现，key是线程，value是值，使用完必须remove，不然会造成线程泄漏。
## java hashmap
- 1.8之前是数组+链表，1.8之后是数组+链表+红黑树。链表长度超过一定值后用红黑树方便查询。
## java ArrayList
- 动态数组，自动扩容1.5倍。
## JVM的理解
- JVM是java跨平台的关键，由三部分组成，类加载系统，执行引擎和运行时数据区。类加载系统用于加载指定的类或接口，执行引擎执行相应的代码，运行时数据区存放数据。
## java垃圾回收
- 垃圾回收机制主要完成三件事情： 1.哪些内存需要回收：废弃的常量，不再被引用的对象等 2.什么时候回收：当类不再被使用 3.如何回收：用引用计数法判断对象是否存活，采用垃圾收集器进行回收。
## springboot常用的注解
- @SpringBootApplication注解，springboot的核心注解，用于开启自动配置，主要是通过EnableAutoConfiguration实现自动配置。
- @EnableAutoConfiguration，自动配置注解，在启动spring应用程序上下文时自动配置，自动配置是基于classpath中引入的类和和已定义的bean来实现的。
- @ComponentScan，用于扫描指定的包和组件
## springboot的启动流程
- springboot项目创建完成后会默认生成一个appication的入口类，类中的main方法可以启动这个项目。main中的run方法可以去实例化这个application类。
## springboot的Ioc与Di
- Ioc 控制反转，一种编程思想，将对象的创建交由SpringIoc管理。之前创建对象都是用new，现在直接从spring容器通过依赖注入的方式获取。
- 有三种注入方式构造器、setter、接口注入。
## AOP面向切片编程
- 通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。它是一种通过预编译方式和运行期间动态代理的方式实现不修改源代码的情况下给程序动态添加功能的一种技术，可以降低代码的耦合度，便于管理，提高代码的可重用性。 AOP的实现方式有两种： JDK动态代理，可以在运行时创建接口的代理实例。CGLIB动态代理：可以在运行期间创建子类的动态实例。 AOP的应用场景有：事务，日志管理等
## @Autowired注解与@resource注解
- @Autowied是Spring提供的注解，@Resource是JDK提供的注解。@Autowied是只能按类型注入，@Resource默认按名称注入，也支持按类型注入。@Autowired按类型装配依赖对象,默认情况下它要求依赖对象必须存在,如果允许null值,可以设置它required属性为false,如果我们想使用按名称装配,可以结合@Qualifier注解一起使用 
## MVC
- MVC是一种设计模式，即Model、View、Controller，view是用户视图，model是数据，controller是数据的处理逻辑，连接model与view，降低代码的耦合、便于代码的维护。
## SpringMVC的执行过程
- 
  
    
